# -*- coding: utf-8 -*-
"""P_EFA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rr9RmhOubPtkI0vHr554pHsxxYeyga5t
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define expected returns and covariance matrix for three assets
expected_returns = np.array([0.2704660114, -0.000004122468015, 0.0161275])  # Expected returns for the 3 assets
cov_matrix = np.array([
    [0.703823,-0.001912,-0.217333],
    [-0.001912,0.000030,0.003180],
    [-0.217333,0.003180,0.622654]
])  # Covariance matrix for the 3 assets

# Risk-free rate
risk_free_rate = 0.07

# Define user-provided portfolio weights for 3 portfolios
user_portfolios = [
    [0.75, 0.1, 0.15],
    [0.5, 0.3, 0.2],
    [0.25, 0.45, 0.30]
]
portfolio_names = ["LIC-A35", "LIC-M35", "LIC-C35"]

# Add custom portfolios with specific weights and names
custom_portfolios = [
    [0.15, 0.1, 0.75],
    [0.1, 0.1, 0.8],
    [0.05, 0.05, 0.9]
]
custom_portfolio_names = ["LIC-A55", "LIC-M55", "LIC-C55"]

# Combine all portfolios and names
all_portfolios = user_portfolios + custom_portfolios
all_names = portfolio_names + custom_portfolio_names

# Function to calculate portfolio metrics
def portfolio_metrics(weights):
    weights = np.array(weights)
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return portfolio_return, portfolio_std_dev, sharpe_ratio

# Calculate metrics for each portfolio
results = [portfolio_metrics(weights) for weights in all_portfolios]
returns, risks, sharpes = zip(*results)

# Find portfolio with the highest Sharpe ratio
max_sharpe_idx = np.argmax(sharpes)
max_sharpe_portfolio = results[max_sharpe_idx]

# Prepare data for plotting the efficient frontier
n_points = 1000
frontier_returns, frontier_risks, frontier_sharpes = [], [], []

# Generate all possible portfolio weight combinations (sum must equal 1)
for i in range(n_points + 1):
    for j in range(n_points + 1 - i):
        w1 = i / n_points
        w2 = j / n_points
        w3 = 1 - w1 - w2
        weights = [w1, w2, w3]
        portfolio_return, portfolio_std_dev, sharpe = portfolio_metrics(weights)
        frontier_returns.append(portfolio_return)
        frontier_risks.append(portfolio_std_dev)
        frontier_sharpes.append(sharpe)

# Plot Efficient Frontier
plt.figure(figsize=(18, 8))
plt.style.use('default')

# Plot all possible portfolios on the Efficient Frontier
sc = plt.scatter(frontier_risks, frontier_returns, c=frontier_sharpes, cmap='viridis', alpha=0.7, s=50)

# Plot each portfolio in user-defined and custom portfolios
for i, name in enumerate(all_names):
    color = 'purple' if i < 3 else 'blue'  # Different color for custom portfolios
    plt.scatter(risks[i], returns[i], color=color, marker='^', s=150, edgecolors='black')  # Ensure correct markings
    plt.text(risks[i] + 0.0001, returns[i], f"{name}", fontsize=12, ha='left', color='black')  # Shifted label positioning

# Highlight the best Sharpe Ratio portfolio
plt.scatter(max_sharpe_portfolio[1], max_sharpe_portfolio[0], color='red', marker='*', s=300, label="Max Sharpe Ratio")

# Add colorbar to show Sharpe Ratio gradient
cbar = plt.colorbar(sc)
cbar.set_label('Sharpe Ratio', fontsize=16)

# Set plot title and labels
plt.title("Efficient Frontier for LIC", fontsize=18, weight='bold')
plt.xlabel("Risk (Standard Deviation)", fontsize=16)
plt.ylabel("Return", fontsize=16)

# Avoid duplicate legend entries and remove specified portfolios from the legend
handles, labels = plt.gca().get_legend_handles_labels()
filtered_handles = [handle for handle, label in zip(handles, labels) if label not in ["LIC-A35", "LIC-A55"]]
filtered_labels = [label for label in labels if label not in ["LIC-A35", "LIC-A55"]]

plt.legend(filtered_handles, filtered_labels, fontsize=12, loc='upper left')

# Print returns, risk, and Sharpe ratio for each portfolio
print("\nPortfolio Metrics (Returns, Risk, Sharpe Ratio):")
for i, (ret, risk, sharpe) in enumerate(results):
    print(f"{all_names[i]} - Return: {ret:.4f}, Risk: {risk:.4f}, Sharpe Ratio: {sharpe:.4f}")

plt.show()



import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define expected returns and covariance matrix for three assets
expected_returns = np.array([0.336526053, 0.1300327159, 0.130228178])  # Expected returns for the 3 assets
cov_matrix = np.array([
    [0.947452,0.041334,0.030862],
    [0.041334,0.016619,0.021134],
    [0.030862,0.021134,0.039318]
])  # Covariance matrix for the 3 assets

# Risk-free rate
risk_free_rate = 0.07

# Define user-provided portfolio weights for 3 portfolios
user_portfolios = [
    [0.75, 0.1, 0.15],
    [0.5, 0.3, 0.2],
    [0.25, 0.45, 0.30]
]
portfolio_names = ["HDFC-A35", "HDFC-M35", "HDFC-C35"]

# Add custom portfolios with specific weights and names
custom_portfolios = [
    [0.15, 0.1, 0.75],
    [0.1, 0.1, 0.8],
    [0.05, 0.05, 0.9]
]
custom_portfolio_names = ["HDFC-A55", "HDFC-M55", "HDFC-C55"]

# Combine all portfolios and names
all_portfolios = user_portfolios + custom_portfolios
all_names = portfolio_names + custom_portfolio_names

# Function to calculate portfolio metrics
def portfolio_metrics(weights):
    weights = np.array(weights)
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return portfolio_return, portfolio_std_dev, sharpe_ratio

# Calculate metrics for each portfolio
results = [portfolio_metrics(weights) for weights in all_portfolios]
returns, risks, sharpes = zip(*results)

# Find portfolio with the highest Sharpe ratio
max_sharpe_idx = np.argmax(sharpes)
max_sharpe_portfolio = results[max_sharpe_idx]

# Prepare data for plotting the efficient frontier
n_points = 1000
frontier_returns, frontier_risks, frontier_sharpes = [], [], []

# Generate all possible portfolio weight combinations (sum must equal 1)
for i in range(n_points + 1):
    for j in range(n_points + 1 - i):
        w1 = i / n_points
        w2 = j / n_points
        w3 = 1 - w1 - w2
        weights = [w1, w2, w3]
        portfolio_return, portfolio_std_dev, sharpe = portfolio_metrics(weights)
        frontier_returns.append(portfolio_return)
        frontier_risks.append(portfolio_std_dev)
        frontier_sharpes.append(sharpe)

# Plot Efficient Frontier
plt.figure(figsize=(18, 8))
plt.style.use('default')

# Plot all possible portfolios on the Efficient Frontier
sc = plt.scatter(frontier_risks, frontier_returns, c=frontier_sharpes, cmap='viridis', alpha=0.7, s=50)

# Plot each portfolio in user-defined and custom portfolios
for i, name in enumerate(all_names):
    color = 'purple' if i < 3 else 'blue'  # Different color for custom portfolios
    plt.scatter(risks[i], returns[i], color=color, marker='^', s=150, edgecolors='black')  # Ensure correct markings
    plt.text(risks[i] + 0.0001, returns[i], f"{name}", fontsize=12, ha='left', color='black')  # Shifted label positioning

# Highlight the best Sharpe Ratio portfolio
plt.scatter(max_sharpe_portfolio[1], max_sharpe_portfolio[0], color='red', marker='*', s=300, label="Max Sharpe Ratio")

# Add colorbar to show Sharpe Ratio gradient
cbar = plt.colorbar(sc)
cbar.set_label('Sharpe Ratio', fontsize=16)

# Set plot title and labels
plt.title("Efficient Frontier for HDFC", fontsize=18, weight='bold')
plt.xlabel("Risk (Standard Deviation)", fontsize=16)
plt.ylabel("Return", fontsize=16)

# Avoid duplicate legend entries and remove specified portfolios from the legend
handles, labels = plt.gca().get_legend_handles_labels()
filtered_handles = [handle for handle, label in zip(handles, labels) if label not in ["LIC-A35", "LIC-A55"]]
filtered_labels = [label for label in labels if label not in ["LIC-A35", "LIC-A55"]]

plt.legend(filtered_handles, filtered_labels, fontsize=12, loc='upper left')

# Print returns, risk, and Sharpe ratio for each portfolio
print("\nPortfolio Metrics (Returns, Risk, Sharpe Ratio):")
for i, (ret, risk, sharpe) in enumerate(results):
    print(f"{all_names[i]} - Return: {ret:.4f}, Risk: {risk:.4f}, Sharpe Ratio: {sharpe:.4f}")

plt.show()



import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define expected returns and covariance matrix for three assets
expected_returns = np.array([0.4523990341, 0.1947856477, 0.1723997955])  # Expected returns for the 3 assets
cov_matrix = np.array([
    [1.771846,0.091700,0.054104],
    [0.091700,0.044412,0.043708],
    [0.054104,0.043708,0.069215]
])  # Covariance matrix for the 3 assets

# Risk-free rate
risk_free_rate = 0.07

# Define user-provided portfolio weights for 3 portfolios
user_portfolios = [
    [0.75, 0.1, 0.15],
    [0.5, 0.3, 0.2],
    [0.25, 0.45, 0.30]
]
portfolio_names = ["ICICI-A35", "ICICI-M35", "ICICI-C35"]

# Add custom portfolios with specific weights and names
custom_portfolios = [
    [0.15, 0.1, 0.75],
    [0.1, 0.1, 0.8],
    [0.05, 0.05, 0.9]
]
custom_portfolio_names = ["ICICI-A55", "ICICI-M55", "ICICI-C55"]

# Combine all portfolios and names
all_portfolios = user_portfolios + custom_portfolios
all_names = portfolio_names + custom_portfolio_names

# Function to calculate portfolio metrics
def portfolio_metrics(weights):
    weights = np.array(weights)
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return portfolio_return, portfolio_std_dev, sharpe_ratio

# Calculate metrics for each portfolio
results = [portfolio_metrics(weights) for weights in all_portfolios]
returns, risks, sharpes = zip(*results)

# Find portfolio with the highest Sharpe ratio
max_sharpe_idx = np.argmax(sharpes)
max_sharpe_portfolio = results[max_sharpe_idx]

# Prepare data for plotting the efficient frontier
n_points = 1000
frontier_returns, frontier_risks, frontier_sharpes = [], [], []

# Generate all possible portfolio weight combinations (sum must equal 1)
for i in range(n_points + 1):
    for j in range(n_points + 1 - i):
        w1 = i / n_points
        w2 = j / n_points
        w3 = 1 - w1 - w2
        weights = [w1, w2, w3]
        portfolio_return, portfolio_std_dev, sharpe = portfolio_metrics(weights)
        frontier_returns.append(portfolio_return)
        frontier_risks.append(portfolio_std_dev)
        frontier_sharpes.append(sharpe)

# Plot Efficient Frontier
plt.figure(figsize=(18, 8))
plt.style.use('default')

# Plot all possible portfolios on the Efficient Frontier
sc = plt.scatter(frontier_risks, frontier_returns, c=frontier_sharpes, cmap='viridis', alpha=0.7, s=50)

# Plot each portfolio in user-defined and custom portfolios
for i, name in enumerate(all_names):
    color = 'purple' if i < 3 else 'blue'  # Different color for custom portfolios
    plt.scatter(risks[i], returns[i], color=color, marker='^', s=150, edgecolors='black')  # Ensure correct markings
    plt.text(risks[i] + 0.0001, returns[i], f"{name}", fontsize=12, ha='left', color='black')  # Shifted label positioning

# Highlight the best Sharpe Ratio portfolio
plt.scatter(max_sharpe_portfolio[1], max_sharpe_portfolio[0], color='red', marker='*', s=300, label="Max Sharpe Ratio")

# Add colorbar to show Sharpe Ratio gradient
cbar = plt.colorbar(sc)
cbar.set_label('Sharpe Ratio', fontsize=16)

# Set plot title and labels
plt.title("Efficient Frontier for ICICI", fontsize=18, weight='bold')
plt.xlabel("Risk (Standard Deviation)", fontsize=16)
plt.ylabel("Return", fontsize=16)

# Avoid duplicate legend entries and remove specified portfolios from the legend
handles, labels = plt.gca().get_legend_handles_labels()
filtered_handles = [handle for handle, label in zip(handles, labels) if label not in ["LIC-A35", "LIC-A55"]]
filtered_labels = [label for label in labels if label not in ["LIC-A35", "LIC-A55"]]

plt.legend(filtered_handles, filtered_labels, fontsize=12, loc='upper left')

# Print returns, risk, and Sharpe ratio for each portfolio
print("\nPortfolio Metrics (Returns, Risk, Sharpe Ratio):")
for i, (ret, risk, sharpe) in enumerate(results):
    print(f"{all_names[i]} - Return: {ret:.4f}, Risk: {risk:.4f}, Sharpe Ratio: {sharpe:.4f}")

plt.show()





import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define expected returns and covariance matrix for three assets
expected_returns = np.array([0.3488929129, 0.1922947083, 0.1884513712])  # Expected returns for the 3 assets
cov_matrix = np.array([
    [1.130434,0.066399,0.050324],
    [0.066399,0.039250,0.047652],
    [0.050324,0.047652,0.080374]
])  # Covariance matrix for the 3 assets

# Risk-free rate
risk_free_rate = 0.07

# Define user-provided portfolio weights for 3 portfolios
user_portfolios = [
    [0.75, 0.1, 0.15],
    [0.5, 0.3, 0.2],
    [0.25, 0.45, 0.30]
]
portfolio_names = ["SBI-A35", "SBI-M35", "SBI-C35"]

# Add custom portfolios with specific weights and names
custom_portfolios = [
    [0.15, 0.1, 0.75],
    [0.1, 0.1, 0.8],
    [0.05, 0.05, 0.9]
]
custom_portfolio_names = ["SBI-A55", "SBI-M55", "SBI-C55"]

# Combine all portfolios and names
all_portfolios = user_portfolios + custom_portfolios
all_names = portfolio_names + custom_portfolio_names

# Function to calculate portfolio metrics
def portfolio_metrics(weights):
    weights = np.array(weights)
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return portfolio_return, portfolio_std_dev, sharpe_ratio

# Calculate metrics for each portfolio
results = [portfolio_metrics(weights) for weights in all_portfolios]
returns, risks, sharpes = zip(*results)

# Find portfolio with the highest Sharpe ratio
max_sharpe_idx = np.argmax(sharpes)
max_sharpe_portfolio = results[max_sharpe_idx]

# Prepare data for plotting the efficient frontier
n_points = 1000
frontier_returns, frontier_risks, frontier_sharpes = [], [], []

# Generate all possible portfolio weight combinations (sum must equal 1)
for i in range(n_points + 1):
    for j in range(n_points + 1 - i):
        w1 = i / n_points
        w2 = j / n_points
        w3 = 1 - w1 - w2
        weights = [w1, w2, w3]
        portfolio_return, portfolio_std_dev, sharpe = portfolio_metrics(weights)
        frontier_returns.append(portfolio_return)
        frontier_risks.append(portfolio_std_dev)
        frontier_sharpes.append(sharpe)

# Plot Efficient Frontier
plt.figure(figsize=(18, 8))
plt.style.use('default')

# Plot all possible portfolios on the Efficient Frontier
sc = plt.scatter(frontier_risks, frontier_returns, c=frontier_sharpes, cmap='viridis', alpha=0.7, s=50)

# Plot each portfolio in user-defined and custom portfolios
for i, name in enumerate(all_names):
    color = 'purple' if i < 3 else 'blue'  # Different color for custom portfolios
    plt.scatter(risks[i], returns[i], color=color, marker='^', s=150, edgecolors='black')  # Ensure correct markings
    plt.text(risks[i] + 0.0001, returns[i], f"{name}", fontsize=12, ha='left', color='black')  # Shifted label positioning

# Highlight the best Sharpe Ratio portfolio
plt.scatter(max_sharpe_portfolio[1], max_sharpe_portfolio[0], color='red', marker='*', s=300, label="Max Sharpe Ratio")

# Add colorbar to show Sharpe Ratio gradient
cbar = plt.colorbar(sc)
cbar.set_label('Sharpe Ratio', fontsize=16)

# Set plot title and labels
plt.title("Efficient Frontier for SBI", fontsize=18, weight='bold')
plt.xlabel("Risk (Standard Deviation)", fontsize=16)
plt.ylabel("Return", fontsize=16)

# Avoid duplicate legend entries and remove specified portfolios from the legend
handles, labels = plt.gca().get_legend_handles_labels()
filtered_handles = [handle for handle, label in zip(handles, labels) if label not in ["LIC-A35", "LIC-A55"]]
filtered_labels = [label for label in labels if label not in ["LIC-A35", "LIC-A55"]]

plt.legend(filtered_handles, filtered_labels, fontsize=12, loc='upper left')

# Print returns, risk, and Sharpe ratio for each portfolio
print("\nPortfolio Metrics (Returns, Risk, Sharpe Ratio):")
for i, (ret, risk, sharpe) in enumerate(results):
    print(f"{all_names[i]} - Return: {ret:.4f}, Risk: {risk:.4f}, Sharpe Ratio: {sharpe:.4f}")

plt.show()

df = pd.read_excel(r"C:\Users\NITRO\Downloads\Research_Data\BOOK5.xlsx")
df
# Calculate the covariance matrix
cov_matrix = df.cov()
cov_matrix

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

# Define expected returns and covariance matrix for three assets
expected_returns = np.array([0.3488929129, 0.1922947083, 0.1884513712])  # Expected returns for the 3 assets
cov_matrix = np.array([
    [1.713424,0.076600,0.052850],
    [0.076600,0.034942,0.041305],
    [0.052850,0.041305,0.066048]
])  # Covariance matrix for the 3 assets

# Risk-free rate
risk_free_rate = 0.07

# Define user-provided portfolio weights for 3 portfolios
user_portfolios = [
    [0.75, 0.1, 0.15],
    [0.5, 0.3, 0.2],
    [0.25, 0.45, 0.30]
]
portfolio_names = ["UTI-A35", "UTI-M35", "UTI-C35"]

# Add custom portfolios with specific weights and names
custom_portfolios = [
    [0.15, 0.1, 0.75],
    [0.1, 0.1, 0.8],
    [0.05, 0.05, 0.9]
]
custom_portfolio_names = ["UTI-A55", "UTI-M55", "UTI-C55"]

# Combine all portfolios and names
all_portfolios = user_portfolios + custom_portfolios
all_names = portfolio_names + custom_portfolio_names

# Function to calculate portfolio metrics
def portfolio_metrics(weights):
    weights = np.array(weights)
    portfolio_return = np.dot(weights, expected_returns)
    portfolio_std_dev = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_std_dev
    return portfolio_return, portfolio_std_dev, sharpe_ratio

# Calculate metrics for each portfolio
results = [portfolio_metrics(weights) for weights in all_portfolios]
returns, risks, sharpes = zip(*results)

# Find portfolio with the highest Sharpe ratio
max_sharpe_idx = np.argmax(sharpes)
max_sharpe_portfolio = results[max_sharpe_idx]

# Prepare data for plotting the efficient frontier
n_points = 1000
frontier_returns, frontier_risks, frontier_sharpes = [], [], []

# Generate all possible portfolio weight combinations (sum must equal 1)
for i in range(n_points + 1):
    for j in range(n_points + 1 - i):
        w1 = i / n_points
        w2 = j / n_points
        w3 = 1 - w1 - w2
        weights = [w1, w2, w3]
        portfolio_return, portfolio_std_dev, sharpe = portfolio_metrics(weights)
        frontier_returns.append(portfolio_return)
        frontier_risks.append(portfolio_std_dev)
        frontier_sharpes.append(sharpe)

# Plot Efficient Frontier
plt.figure(figsize=(18, 8))
plt.style.use('default')

# Plot all possible portfolios on the Efficient Frontier
sc = plt.scatter(frontier_risks, frontier_returns, c=frontier_sharpes, cmap='viridis', alpha=0.7, s=50)

# Plot each portfolio in user-defined and custom portfolios
for i, name in enumerate(all_names):
    color = 'purple' if i < 3 else 'blue'  # Different color for custom portfolios
    plt.scatter(risks[i], returns[i], color=color, marker='^', s=150, edgecolors='black')  # Ensure correct markings
    plt.text(risks[i] + 0.0001, returns[i], f"{name}", fontsize=12, ha='left', color='black')  # Shifted label positioning

# Highlight the best Sharpe Ratio portfolio
plt.scatter(max_sharpe_portfolio[1], max_sharpe_portfolio[0], color='red', marker='*', s=300, label="Max Sharpe Ratio")

# Add colorbar to show Sharpe Ratio gradient
cbar = plt.colorbar(sc)
cbar.set_label('Sharpe Ratio', fontsize=16)

# Set plot title and labels
plt.title("Efficient Frontier for UTI", fontsize=18, weight='bold')
plt.xlabel("Risk (Standard Deviation)", fontsize=16)
plt.ylabel("Return", fontsize=16)

# Avoid duplicate legend entries and remove specified portfolios from the legend
handles, labels = plt.gca().get_legend_handles_labels()
filtered_handles = [handle for handle, label in zip(handles, labels) if label not in ["LIC-A35", "LIC-A55"]]
filtered_labels = [label for label in labels if label not in ["LIC-A35", "LIC-A55"]]

plt.legend(filtered_handles, filtered_labels, fontsize=12, loc='upper left')

# Print returns, risk, and Sharpe ratio for each portfolio
print("\nPortfolio Metrics (Returns, Risk, Sharpe Ratio):")
for i, (ret, risk, sharpe) in enumerate(results):
    print(f"{all_names[i]} - Return: {ret:.4f}, Risk: {risk:.4f}, Sharpe Ratio: {sharpe:.4f}")

plt.show()













